"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/extractSectionGroups.js":
/*!*************************************!*\
  !*** ./lib/extractSectionGroups.js ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ extractSectionGroups; }\n/* harmony export */ });\n/* harmony import */ var _config_sectionSummaryConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/sectionSummaryConfig */ \"(app-pages-browser)/./config/sectionSummaryConfig.js\");\n/**\n * Author: Dr MartÃ­n Raskovsky\n * Date: April 2025\n *\n * Updated: April 2025\n * \n * Also extracts diffs and total diffs alongside sections.\n * \n * NOTE: Section diffs are stored as arrays indexed by wallet position, not by wallet address.\n* This design assumes wallet ordering consistency during section extraction.\n */ \n/**\n * Extracts grouped section data from multiple chains (evm, sol, tez).\n *\n * @param {object} data - Full dataset including data.evm, data.sol, etc.\n * @param {Array} chainList - List of supported chain keys (e.g., ['evm', 'sol', 'tez'])\n * @returns {object} - { groups, sectionToNetwork }\n */ function extractSectionGroups(data, chainList) {\n    const sectionToNetwork = {};\n    const groups = [];\n    for (const group of _config_sectionSummaryConfig__WEBPACK_IMPORTED_MODULE_0__[\"default\"]){\n        const sections = [];\n        for (const chain of chainList){\n            const cdata = data[chain];\n            if (!cdata || !cdata.sectionTitles) continue;\n            const wallets = cdata.wallets || [];\n            for (const title of group.sections){\n                var _cdata___diffs, _cdata___diff_totals, _cdata_networkKeys;\n                const index = cdata.sectionTitles.indexOf(title);\n                if (index === -1) continue;\n                const sectionKey = cdata.sectionKeys[index];\n                const rawValues = cdata[sectionKey] || [];\n                const total = cdata[cdata.totalKeys[index]] || \"0\";\n                const entries = rawValues.map((value, i)=>({\n                        address: wallets[i],\n                        value\n                    }));\n                const diffs = ((_cdata___diffs = cdata.__diffs) === null || _cdata___diffs === void 0 ? void 0 : _cdata___diffs[sectionKey]) || {};\n                const totalDiff = ((_cdata___diff_totals = cdata.__diff_totals) === null || _cdata___diff_totals === void 0 ? void 0 : _cdata___diff_totals[index]) || \"\";\n                sections.push({\n                    sectionKey,\n                    label: title,\n                    entries,\n                    total,\n                    diffs,\n                    totalDiff\n                });\n                sectionToNetwork[sectionKey] = ((_cdata_networkKeys = cdata.networkKeys) === null || _cdata_networkKeys === void 0 ? void 0 : _cdata_networkKeys[index]) || \"UNKNOWN\";\n            }\n        }\n        if (sections.length > 0) {\n            groups.push({\n                title: group.name,\n                sections\n            });\n        }\n    }\n    return {\n        groups,\n        sectionToNetwork\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9leHRyYWN0U2VjdGlvbkdyb3Vwcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Ozs7Ozs7O0NBVUMsR0FFaUU7QUFFbEU7Ozs7OztDQU1DLEdBQ2MsU0FBU0MscUJBQXFCQyxJQUFJLEVBQUVDLFNBQVM7SUFDMUQsTUFBTUMsbUJBQW1CLENBQUM7SUFDMUIsTUFBTUMsU0FBUyxFQUFFO0lBRWpCLEtBQUssTUFBTUMsU0FBU04sb0VBQW9CQSxDQUFFO1FBQ3hDLE1BQU1PLFdBQVcsRUFBRTtRQUVuQixLQUFLLE1BQU1DLFNBQVNMLFVBQVc7WUFDN0IsTUFBTU0sUUFBUVAsSUFBSSxDQUFDTSxNQUFNO1lBQ3pCLElBQUksQ0FBQ0MsU0FBUyxDQUFDQSxNQUFNQyxhQUFhLEVBQUU7WUFFcEMsTUFBTUMsVUFBVUYsTUFBTUUsT0FBTyxJQUFJLEVBQUU7WUFFbkMsS0FBSyxNQUFNQyxTQUFTTixNQUFNQyxRQUFRLENBQUU7b0JBYXBCRSxnQkFDSUEsc0JBV2FBO2dCQXhCL0IsTUFBTUksUUFBUUosTUFBTUMsYUFBYSxDQUFDSSxPQUFPLENBQUNGO2dCQUMxQyxJQUFJQyxVQUFVLENBQUMsR0FBRztnQkFFbEIsTUFBTUUsYUFBYU4sTUFBTU8sV0FBVyxDQUFDSCxNQUFNO2dCQUMzQyxNQUFNSSxZQUFZUixLQUFLLENBQUNNLFdBQVcsSUFBSSxFQUFFO2dCQUN6QyxNQUFNRyxRQUFRVCxLQUFLLENBQUNBLE1BQU1VLFNBQVMsQ0FBQ04sTUFBTSxDQUFDLElBQUk7Z0JBRS9DLE1BQU1PLFVBQVVILFVBQVVJLEdBQUcsQ0FBQyxDQUFDQyxPQUFPQyxJQUFPO3dCQUMzQ0MsU0FBU2IsT0FBTyxDQUFDWSxFQUFFO3dCQUNuQkQ7b0JBQ0Y7Z0JBRUEsTUFBTUcsUUFBUWhCLEVBQUFBLGlCQUFBQSxNQUFNaUIsT0FBTyxjQUFiakIscUNBQUFBLGNBQWUsQ0FBQ00sV0FBVyxLQUFJLENBQUM7Z0JBQzlDLE1BQU1ZLFlBQVlsQixFQUFBQSx1QkFBQUEsTUFBTW1CLGFBQWEsY0FBbkJuQiwyQ0FBQUEsb0JBQXFCLENBQUNJLE1BQU0sS0FBSTtnQkFFbEROLFNBQVNzQixJQUFJLENBQUM7b0JBQ1pkO29CQUNBZSxPQUFPbEI7b0JBQ1BRO29CQUNBRjtvQkFDQU87b0JBQ0FFO2dCQUNGO2dCQUVBdkIsZ0JBQWdCLENBQUNXLFdBQVcsR0FBR04sRUFBQUEscUJBQUFBLE1BQU1zQixXQUFXLGNBQWpCdEIseUNBQUFBLGtCQUFtQixDQUFDSSxNQUFNLEtBQUk7WUFDL0Q7UUFDRjtRQUVBLElBQUlOLFNBQVN5QixNQUFNLEdBQUcsR0FBRztZQUN2QjNCLE9BQU93QixJQUFJLENBQUM7Z0JBQUVqQixPQUFPTixNQUFNMkIsSUFBSTtnQkFBRTFCO1lBQVM7UUFDNUM7SUFDRjtJQUVBLE9BQU87UUFBRUY7UUFBUUQ7SUFBaUI7QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2V4dHJhY3RTZWN0aW9uR3JvdXBzLmpzP2U1OWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBdXRob3I6IERyIE1hcnTDrW4gUmFza292c2t5XG4gKiBEYXRlOiBBcHJpbCAyMDI1XG4gKlxuICogVXBkYXRlZDogQXByaWwgMjAyNVxuICogXG4gKiBBbHNvIGV4dHJhY3RzIGRpZmZzIGFuZCB0b3RhbCBkaWZmcyBhbG9uZ3NpZGUgc2VjdGlvbnMuXG4gKiBcbiAqIE5PVEU6IFNlY3Rpb24gZGlmZnMgYXJlIHN0b3JlZCBhcyBhcnJheXMgaW5kZXhlZCBieSB3YWxsZXQgcG9zaXRpb24sIG5vdCBieSB3YWxsZXQgYWRkcmVzcy5cbiogVGhpcyBkZXNpZ24gYXNzdW1lcyB3YWxsZXQgb3JkZXJpbmcgY29uc2lzdGVuY3kgZHVyaW5nIHNlY3Rpb24gZXh0cmFjdGlvbi5cbiAqL1xuXG5pbXBvcnQgc2VjdGlvblN1bW1hcnlDb25maWcgZnJvbSAnLi4vY29uZmlnL3NlY3Rpb25TdW1tYXJ5Q29uZmlnJztcblxuLyoqXG4gKiBFeHRyYWN0cyBncm91cGVkIHNlY3Rpb24gZGF0YSBmcm9tIG11bHRpcGxlIGNoYWlucyAoZXZtLCBzb2wsIHRleikuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRhdGEgLSBGdWxsIGRhdGFzZXQgaW5jbHVkaW5nIGRhdGEuZXZtLCBkYXRhLnNvbCwgZXRjLlxuICogQHBhcmFtIHtBcnJheX0gY2hhaW5MaXN0IC0gTGlzdCBvZiBzdXBwb3J0ZWQgY2hhaW4ga2V5cyAoZS5nLiwgWydldm0nLCAnc29sJywgJ3RleiddKVxuICogQHJldHVybnMge29iamVjdH0gLSB7IGdyb3Vwcywgc2VjdGlvblRvTmV0d29yayB9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGV4dHJhY3RTZWN0aW9uR3JvdXBzKGRhdGEsIGNoYWluTGlzdCkge1xuICBjb25zdCBzZWN0aW9uVG9OZXR3b3JrID0ge307XG4gIGNvbnN0IGdyb3VwcyA9IFtdO1xuXG4gIGZvciAoY29uc3QgZ3JvdXAgb2Ygc2VjdGlvblN1bW1hcnlDb25maWcpIHtcbiAgICBjb25zdCBzZWN0aW9ucyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBjaGFpbiBvZiBjaGFpbkxpc3QpIHtcbiAgICAgIGNvbnN0IGNkYXRhID0gZGF0YVtjaGFpbl07XG4gICAgICBpZiAoIWNkYXRhIHx8ICFjZGF0YS5zZWN0aW9uVGl0bGVzKSBjb250aW51ZTtcblxuICAgICAgY29uc3Qgd2FsbGV0cyA9IGNkYXRhLndhbGxldHMgfHwgW107XG5cbiAgICAgIGZvciAoY29uc3QgdGl0bGUgb2YgZ3JvdXAuc2VjdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBjZGF0YS5zZWN0aW9uVGl0bGVzLmluZGV4T2YodGl0bGUpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSBjb250aW51ZTtcblxuICAgICAgICBjb25zdCBzZWN0aW9uS2V5ID0gY2RhdGEuc2VjdGlvbktleXNbaW5kZXhdO1xuICAgICAgICBjb25zdCByYXdWYWx1ZXMgPSBjZGF0YVtzZWN0aW9uS2V5XSB8fCBbXTtcbiAgICAgICAgY29uc3QgdG90YWwgPSBjZGF0YVtjZGF0YS50b3RhbEtleXNbaW5kZXhdXSB8fCAnMCc7XG5cbiAgICAgICAgY29uc3QgZW50cmllcyA9IHJhd1ZhbHVlcy5tYXAoKHZhbHVlLCBpKSA9PiAoe1xuICAgICAgICAgIGFkZHJlc3M6IHdhbGxldHNbaV0sXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIGNvbnN0IGRpZmZzID0gY2RhdGEuX19kaWZmcz8uW3NlY3Rpb25LZXldIHx8IHt9O1xuICAgICAgICBjb25zdCB0b3RhbERpZmYgPSBjZGF0YS5fX2RpZmZfdG90YWxzPy5baW5kZXhdIHx8ICcnO1xuXG4gICAgICAgIHNlY3Rpb25zLnB1c2goeyBcbiAgICAgICAgICBzZWN0aW9uS2V5LCBcbiAgICAgICAgICBsYWJlbDogdGl0bGUsIFxuICAgICAgICAgIGVudHJpZXMsIFxuICAgICAgICAgIHRvdGFsLFxuICAgICAgICAgIGRpZmZzLCAgICAgICAgLy8g8J+OryBBRERFRFxuICAgICAgICAgIHRvdGFsRGlmZiAgICAgLy8g8J+OryBBRERFRFxuICAgICAgICB9KTtcblxuICAgICAgICBzZWN0aW9uVG9OZXR3b3JrW3NlY3Rpb25LZXldID0gY2RhdGEubmV0d29ya0tleXM/LltpbmRleF0gfHwgJ1VOS05PV04nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBncm91cHMucHVzaCh7IHRpdGxlOiBncm91cC5uYW1lLCBzZWN0aW9ucyB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4geyBncm91cHMsIHNlY3Rpb25Ub05ldHdvcmsgfTtcbn1cblxuIl0sIm5hbWVzIjpbInNlY3Rpb25TdW1tYXJ5Q29uZmlnIiwiZXh0cmFjdFNlY3Rpb25Hcm91cHMiLCJkYXRhIiwiY2hhaW5MaXN0Iiwic2VjdGlvblRvTmV0d29yayIsImdyb3VwcyIsImdyb3VwIiwic2VjdGlvbnMiLCJjaGFpbiIsImNkYXRhIiwic2VjdGlvblRpdGxlcyIsIndhbGxldHMiLCJ0aXRsZSIsImluZGV4IiwiaW5kZXhPZiIsInNlY3Rpb25LZXkiLCJzZWN0aW9uS2V5cyIsInJhd1ZhbHVlcyIsInRvdGFsIiwidG90YWxLZXlzIiwiZW50cmllcyIsIm1hcCIsInZhbHVlIiwiaSIsImFkZHJlc3MiLCJkaWZmcyIsIl9fZGlmZnMiLCJ0b3RhbERpZmYiLCJfX2RpZmZfdG90YWxzIiwicHVzaCIsImxhYmVsIiwibmV0d29ya0tleXMiLCJsZW5ndGgiLCJuYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/extractSectionGroups.js\n"));

/***/ })

});