"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/extractSectionGroups.js":
/*!*************************************!*\
  !*** ./lib/extractSectionGroups.js ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ extractSectionGroups; }\n/* harmony export */ });\n/* harmony import */ var _config_sectionSummaryConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config/sectionSummaryConfig */ \"(app-pages-browser)/./config/sectionSummaryConfig.js\");\n/**\n * Author: Dr MartÃ­n Raskovsky\n * Date: April 2025\n *\n * Updated: April 2025\n * \n * Also extracts diffs and total diffs alongside sections.\n * \n * NOTE: Section diffs are stored as arrays indexed by wallet position, not by wallet address.\n * This design assumes wallet ordering consistency during section extraction.\n */ \n/**\n * Extracts grouped section data from multiple chains (evm, sol, tez).\n *\n * @param {object} data - Full dataset including data.evm, data.sol, etc.\n * @param {Array} chainList - List of supported chain keys (e.g., ['evm', 'sol', 'tez'])\n * @returns {object} - { groups, sectionToNetwork }\n */ function extractSectionGroups(data, chainList) {\n    const sectionToNetwork = {};\n    const groups = [];\n    for (const group of _config_sectionSummaryConfig__WEBPACK_IMPORTED_MODULE_0__[\"default\"]){\n        const sections = [];\n        for (const chain of chainList){\n            const cdata = data[chain];\n            if (!cdata || !cdata.sectionTitles) continue;\n            const wallets = cdata.wallets || [];\n            for (const title of group.sections){\n                var _cdata___diffs, _cdata___diff_totals, _cdata_networkKeys;\n                const index = cdata.sectionTitles.indexOf(title);\n                if (index === -1) continue;\n                const sectionKey = cdata.sectionKeys[index];\n                const rawValues = cdata[sectionKey] || [];\n                const total = cdata[cdata.totalKeys[index]] || \"0\";\n                const entries = rawValues.map((value, i)=>({\n                        address: wallets[i],\n                        value\n                    }));\n                const diffs = ((_cdata___diffs = cdata.__diffs) === null || _cdata___diffs === void 0 ? void 0 : _cdata___diffs[sectionKey]) || {};\n                const totalDiff = ((_cdata___diff_totals = cdata.__diff_totals) === null || _cdata___diff_totals === void 0 ? void 0 : _cdata___diff_totals[index]) || \"\";\n                sections.push({\n                    sectionKey,\n                    label: title,\n                    entries,\n                    total,\n                    diffs,\n                    totalDiff\n                });\n                sectionToNetwork[sectionKey] = ((_cdata_networkKeys = cdata.networkKeys) === null || _cdata_networkKeys === void 0 ? void 0 : _cdata_networkKeys[index]) || \"UNKNOWN\";\n            }\n        }\n        if (sections.length > 0) {\n            groups.push({\n                title: group.name,\n                sections\n            });\n        }\n    }\n    return {\n        groups,\n        sectionToNetwork\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9leHRyYWN0U2VjdGlvbkdyb3Vwcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Ozs7Ozs7O0NBVUMsR0FFaUU7QUFFbEU7Ozs7OztDQU1DLEdBQ2MsU0FBU0MscUJBQXFCQyxJQUFJLEVBQUVDLFNBQVM7SUFDMUQsTUFBTUMsbUJBQW1CLENBQUM7SUFDMUIsTUFBTUMsU0FBUyxFQUFFO0lBRWpCLEtBQUssTUFBTUMsU0FBU04sb0VBQW9CQSxDQUFFO1FBQ3hDLE1BQU1PLFdBQVcsRUFBRTtRQUVuQixLQUFLLE1BQU1DLFNBQVNMLFVBQVc7WUFDN0IsTUFBTU0sUUFBUVAsSUFBSSxDQUFDTSxNQUFNO1lBQ3pCLElBQUksQ0FBQ0MsU0FBUyxDQUFDQSxNQUFNQyxhQUFhLEVBQUU7WUFFcEMsTUFBTUMsVUFBVUYsTUFBTUUsT0FBTyxJQUFJLEVBQUU7WUFFbkMsS0FBSyxNQUFNQyxTQUFTTixNQUFNQyxRQUFRLENBQUU7b0JBYXBCRSxnQkFDSUEsc0JBV2FBO2dCQXhCL0IsTUFBTUksUUFBUUosTUFBTUMsYUFBYSxDQUFDSSxPQUFPLENBQUNGO2dCQUMxQyxJQUFJQyxVQUFVLENBQUMsR0FBRztnQkFFbEIsTUFBTUUsYUFBYU4sTUFBTU8sV0FBVyxDQUFDSCxNQUFNO2dCQUMzQyxNQUFNSSxZQUFZUixLQUFLLENBQUNNLFdBQVcsSUFBSSxFQUFFO2dCQUN6QyxNQUFNRyxRQUFRVCxLQUFLLENBQUNBLE1BQU1VLFNBQVMsQ0FBQ04sTUFBTSxDQUFDLElBQUk7Z0JBRS9DLE1BQU1PLFVBQVVILFVBQVVJLEdBQUcsQ0FBQyxDQUFDQyxPQUFPQyxJQUFPO3dCQUMzQ0MsU0FBU2IsT0FBTyxDQUFDWSxFQUFFO3dCQUNuQkQ7b0JBQ0Y7Z0JBRUEsTUFBTUcsUUFBUWhCLEVBQUFBLGlCQUFBQSxNQUFNaUIsT0FBTyxjQUFiakIscUNBQUFBLGNBQWUsQ0FBQ00sV0FBVyxLQUFJLENBQUM7Z0JBQzlDLE1BQU1ZLFlBQVlsQixFQUFBQSx1QkFBQUEsTUFBTW1CLGFBQWEsY0FBbkJuQiwyQ0FBQUEsb0JBQXFCLENBQUNJLE1BQU0sS0FBSTtnQkFFbEROLFNBQVNzQixJQUFJLENBQUM7b0JBQ1pkO29CQUNBZSxPQUFPbEI7b0JBQ1BRO29CQUNBRjtvQkFDQU87b0JBQ0FFO2dCQUNGO2dCQUVBdkIsZ0JBQWdCLENBQUNXLFdBQVcsR0FBR04sRUFBQUEscUJBQUFBLE1BQU1zQixXQUFXLGNBQWpCdEIseUNBQUFBLGtCQUFtQixDQUFDSSxNQUFNLEtBQUk7WUFDL0Q7UUFDRjtRQUVBLElBQUlOLFNBQVN5QixNQUFNLEdBQUcsR0FBRztZQUN2QjNCLE9BQU93QixJQUFJLENBQUM7Z0JBQUVqQixPQUFPTixNQUFNMkIsSUFBSTtnQkFBRTFCO1lBQVM7UUFDNUM7SUFDRjtJQUVBLE9BQU87UUFBRUY7UUFBUUQ7SUFBaUI7QUFDcEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbGliL2V4dHJhY3RTZWN0aW9uR3JvdXBzLmpzP2U1OWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBdXRob3I6IERyIE1hcnTDrW4gUmFza292c2t5XG4gKiBEYXRlOiBBcHJpbCAyMDI1XG4gKlxuICogVXBkYXRlZDogQXByaWwgMjAyNVxuICogXG4gKiBBbHNvIGV4dHJhY3RzIGRpZmZzIGFuZCB0b3RhbCBkaWZmcyBhbG9uZ3NpZGUgc2VjdGlvbnMuXG4gKiBcbiAqIE5PVEU6IFNlY3Rpb24gZGlmZnMgYXJlIHN0b3JlZCBhcyBhcnJheXMgaW5kZXhlZCBieSB3YWxsZXQgcG9zaXRpb24sIG5vdCBieSB3YWxsZXQgYWRkcmVzcy5cbiAqIFRoaXMgZGVzaWduIGFzc3VtZXMgd2FsbGV0IG9yZGVyaW5nIGNvbnNpc3RlbmN5IGR1cmluZyBzZWN0aW9uIGV4dHJhY3Rpb24uXG4gKi9cblxuaW1wb3J0IHNlY3Rpb25TdW1tYXJ5Q29uZmlnIGZyb20gJy4uL2NvbmZpZy9zZWN0aW9uU3VtbWFyeUNvbmZpZyc7XG5cbi8qKlxuICogRXh0cmFjdHMgZ3JvdXBlZCBzZWN0aW9uIGRhdGEgZnJvbSBtdWx0aXBsZSBjaGFpbnMgKGV2bSwgc29sLCB0ZXopLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkYXRhIC0gRnVsbCBkYXRhc2V0IGluY2x1ZGluZyBkYXRhLmV2bSwgZGF0YS5zb2wsIGV0Yy5cbiAqIEBwYXJhbSB7QXJyYXl9IGNoYWluTGlzdCAtIExpc3Qgb2Ygc3VwcG9ydGVkIGNoYWluIGtleXMgKGUuZy4sIFsnZXZtJywgJ3NvbCcsICd0ZXonXSlcbiAqIEByZXR1cm5zIHtvYmplY3R9IC0geyBncm91cHMsIHNlY3Rpb25Ub05ldHdvcmsgfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBleHRyYWN0U2VjdGlvbkdyb3VwcyhkYXRhLCBjaGFpbkxpc3QpIHtcbiAgY29uc3Qgc2VjdGlvblRvTmV0d29yayA9IHt9O1xuICBjb25zdCBncm91cHMgPSBbXTtcblxuICBmb3IgKGNvbnN0IGdyb3VwIG9mIHNlY3Rpb25TdW1tYXJ5Q29uZmlnKSB7XG4gICAgY29uc3Qgc2VjdGlvbnMgPSBbXTtcblxuICAgIGZvciAoY29uc3QgY2hhaW4gb2YgY2hhaW5MaXN0KSB7XG4gICAgICBjb25zdCBjZGF0YSA9IGRhdGFbY2hhaW5dO1xuICAgICAgaWYgKCFjZGF0YSB8fCAhY2RhdGEuc2VjdGlvblRpdGxlcykgY29udGludWU7XG5cbiAgICAgIGNvbnN0IHdhbGxldHMgPSBjZGF0YS53YWxsZXRzIHx8IFtdO1xuXG4gICAgICBmb3IgKGNvbnN0IHRpdGxlIG9mIGdyb3VwLnNlY3Rpb25zKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gY2RhdGEuc2VjdGlvblRpdGxlcy5pbmRleE9mKHRpdGxlKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkgY29udGludWU7XG5cbiAgICAgICAgY29uc3Qgc2VjdGlvbktleSA9IGNkYXRhLnNlY3Rpb25LZXlzW2luZGV4XTtcbiAgICAgICAgY29uc3QgcmF3VmFsdWVzID0gY2RhdGFbc2VjdGlvbktleV0gfHwgW107XG4gICAgICAgIGNvbnN0IHRvdGFsID0gY2RhdGFbY2RhdGEudG90YWxLZXlzW2luZGV4XV0gfHwgJzAnO1xuXG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSByYXdWYWx1ZXMubWFwKCh2YWx1ZSwgaSkgPT4gKHtcbiAgICAgICAgICBhZGRyZXNzOiB3YWxsZXRzW2ldLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0pKTtcblxuICAgICAgICBjb25zdCBkaWZmcyA9IGNkYXRhLl9fZGlmZnM/LltzZWN0aW9uS2V5XSB8fCB7fTtcbiAgICAgICAgY29uc3QgdG90YWxEaWZmID0gY2RhdGEuX19kaWZmX3RvdGFscz8uW2luZGV4XSB8fCAnJztcblxuICAgICAgICBzZWN0aW9ucy5wdXNoKHsgXG4gICAgICAgICAgc2VjdGlvbktleSwgXG4gICAgICAgICAgbGFiZWw6IHRpdGxlLCBcbiAgICAgICAgICBlbnRyaWVzLCBcbiAgICAgICAgICB0b3RhbCxcbiAgICAgICAgICBkaWZmcywgICAgICAgIC8vIPCfjq8gQURERURcbiAgICAgICAgICB0b3RhbERpZmYgICAgIC8vIPCfjq8gQURERURcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2VjdGlvblRvTmV0d29ya1tzZWN0aW9uS2V5XSA9IGNkYXRhLm5ldHdvcmtLZXlzPy5baW5kZXhdIHx8ICdVTktOT1dOJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgZ3JvdXBzLnB1c2goeyB0aXRsZTogZ3JvdXAubmFtZSwgc2VjdGlvbnMgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgZ3JvdXBzLCBzZWN0aW9uVG9OZXR3b3JrIH07XG59XG5cbiJdLCJuYW1lcyI6WyJzZWN0aW9uU3VtbWFyeUNvbmZpZyIsImV4dHJhY3RTZWN0aW9uR3JvdXBzIiwiZGF0YSIsImNoYWluTGlzdCIsInNlY3Rpb25Ub05ldHdvcmsiLCJncm91cHMiLCJncm91cCIsInNlY3Rpb25zIiwiY2hhaW4iLCJjZGF0YSIsInNlY3Rpb25UaXRsZXMiLCJ3YWxsZXRzIiwidGl0bGUiLCJpbmRleCIsImluZGV4T2YiLCJzZWN0aW9uS2V5Iiwic2VjdGlvbktleXMiLCJyYXdWYWx1ZXMiLCJ0b3RhbCIsInRvdGFsS2V5cyIsImVudHJpZXMiLCJtYXAiLCJ2YWx1ZSIsImkiLCJhZGRyZXNzIiwiZGlmZnMiLCJfX2RpZmZzIiwidG90YWxEaWZmIiwiX19kaWZmX3RvdGFscyIsInB1c2giLCJsYWJlbCIsIm5ldHdvcmtLZXlzIiwibGVuZ3RoIiwibmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/extractSectionGroups.js\n"));

/***/ })

});